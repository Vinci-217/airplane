<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>一文归纳数据库集群技术要点</title>
<meta charset=utf-8><meta name=description content="Ladder@数据库是服务端开发离不开的中间件，为了提高大型项目中数据库的可用性，常常通过集群的方式部署数据库。本文将从数据库集群的技术要点出发，介绍基于 MySQL 和 Redis 的数据库集群方案。"><meta name=author content="Airplane"><link rel=canonical href=https://vinci-217.github.io/blog/database-cluster/><link rel=alternate type=application/rss+xml href=https://vinci-217.github.io//index.xml title="Airplane Space"><meta property="og:url" content="https://vinci-217.github.io/blog/database-cluster/"><meta property="og:site_name" content="Airplane Space"><meta property="og:title" content="一文归纳数据库集群技术要点"><meta property="og:description" content="数据库是服务端开发离不开的中间件，为了提高大型项目中数据库的可用性，常常通过集群的方式部署数据库。本文将从数据库集群的技术要点出发，介绍基于 MySQL 和 Redis 的数据库集群方案。"><meta property="og:locale" content="zn_ch"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-07T19:52:18+08:00"><meta property="article:modified_time" content="2025-02-07T19:52:18+08:00"><meta property="article:tag" content="MySQL"><meta property="article:tag" content="Redis"><meta property="article:tag" content="Cluster"><meta name=twitter:card content="summary"><meta name=twitter:title content="一文归纳数据库集群技术要点"><meta name=twitter:description content="数据库是服务端开发离不开的中间件，为了提高大型项目中数据库的可用性，常常通过集群的方式部署数据库。本文将从数据库集群的技术要点出发，介绍基于 MySQL 和 Redis 的数据库集群方案。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://vinci-217.github.io/blog/"},{"@type":"ListItem","position":2,"name":"一文归纳数据库集群技术要点","item":"https://vinci-217.github.io/blog/database-cluster/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"一文归纳数据库集群技术要点","name":"一文归纳数据库集群技术要点","description":"数据库是服务端开发离不开的中间件，为了提高大型项目中数据库的可用性，常常通过集群的方式部署数据库。本文将从数据库集群的技术要点出发，介绍基于 MySQL 和 Redis 的数据库集群方案。\n","keywords":["MySQL","Redis","Cluster"],"articleBody":"数据库是服务端开发离不开的中间件，为了提高大型项目中数据库的可用性，常常通过集群的方式部署数据库。本文将从数据库集群的技术要点出发，介绍基于 MySQL 和 Redis 的数据库集群方案。\nMySQL MySQL 最初是一种单机的数据库系统，他的集群出现主要是为了应对高并发读写和数据库宕机的场景。针对这样的场景，MySQL 采用了多个服务集群部署、读写分离等策略来应对。MySQL 集群的方式有很多种，目的都是为了提高其可用性。\n读写分离 读写分离是提高 MySQL 并发量的一种策略，其含义是使用多个具有相同数据的 MySQL 实例来分担大量查询请求。其本质上是有一个或多个主节点作为客户端写入的实例，其他的实例作为备份节点，提供只读的服务。\n读写分离本质上相当于一种请求的负载均衡，将读请求分担到多个从节点，将写请求分担到主节点。但也会面临一些集群的问题。根据经典的 CAP 理论，网络分区容忍性必须保证，那么一致性和可用性就成为一个值得权衡的点。最明显的就是由于主从同步的延迟，可能会出现数据不一致的问题。\n集群模式 MySQL Replication MySQL Replication 最基本的 MySQL 集群功能，基于一主多从的架构，主库负责写数据，从库负责读数据。主库会将数据变更记录在 binlog 中，从库通过读取主库的 binlog 来获取主库的最新数据，相当于主库的 sql 语句在从库上又执行了一遍。\nMySQL Fabirc MySQL Fabric 是在 MySQL Replication 的基础上，增加的故障检测与转移、自动数据分片的功能。但是依然是基于一主多从的架构，主库负责写数据，从库负责读数据。MySQL Fabric 只有一个主节点，但是当主节点挂掉以后，会从从节点中选一个来当主节点。\nMySQL Cluster MySQL Cluster 是一种多主多从的架构，也是由 MySQL 官方提供。他的高可用、负载均衡、伸缩性都很优秀，但是架构模式和原理很复杂，并且只能使用 NDB 存储引擎而不是 InnoDB 存储引擎（比如在事务隔离级别上只支持 Read Committed）。\n主从同步 MySQL 的集群之间的数据同步是基于 binlog 的。binlog 是 MySQL 服务器的二进制日志，记录了对数据库的修改，包括增删改操作。通过 binlog，可以将数据同步到其他的 MySQL 服务器，实现数据库集群的数据一致性。\nbinlog 有三种格式，一种是 statement，一种是 row，还有一种是 mixed。statement 格式的 binlog 记录的是 SQL 语句的原始文本，row 格式的 binlog 记录的是每行数据的修改，mixed 格式的 binlog 既记录 SQL 语句，又记录每行数据的修改。\n假如我们执行一个删除的 SQL，delete from table1 where id \u003e 100 limit 1，由于 limit 这个命令，可能导致从库具体的这个 limit 1 和主库的 limit 1 不是同一行数据，所以造成误删的风险，那么 row 格式的 binlog 就应运而生了。但是由于每次记录 row 类型的 binlog 对内存开销太大，所以就有了 mixed 格式的 binlog——既记录 SQL 语句，又记录每行数据的修改，做了两者之间的权衡。\n不同的集群模式主从同步的方式也不太一样，但大致流程相似：\n主库接收到客户端的更新请求，执行更新操作并写入 binlog 从库在主从之间简历长连接 主库的 dump_tread 从本地读取 binlog 给从库 从库获取到主库的 binlog 后存储到本地，成为 relay log 从库的 sql_thread 读取 relay log，解析出具体的 sql 语句，执行 sql 语句 主从库之间的数据借助 binlog 进行复制，数据复制的一般分为同步和异步两种。同步复制就是主库接收到写请求完成以后，会等待副本的写请求也完成，才返回客户端，而异步复制就是主库直接返回客户端，不等待副本的写请求完成，然后让异步线程去处理副本的写请求。很经典的问题出现了：同步复制能够很好保证数据一致性，但是性能差；异步复制反之。\n其实除了我们讨论的主从复制，还有多主复制、无主复制等演化得到的不同的主从模型，此处就不在深入讨论了。\nMySQL 5.7 版本引入了半同步复制。异步复制是事务线程完全不等复制响应。同步复制是事务线程要等所有复制响应。半同步复制就是等待一部分复制响应就认为成功。\n比较重要的是半同步复制。\n半同步复制过程中有一个参数“rpl_semi_sync_master_wait_no_slave”，默认值是 1，表示等待至少一个从库的响应，如果设置为大于 1 的值，表示等待指定数量的从库的响应。\n还有一个是”rpl_semi_sync_master_wait_point“，表示的是主库提交事务之前等待复制还是提交事务之后等待复制。，默认是先等待复制（AFTER_SYNC），再提交事务，这样不会完全丢数据。相反的配置（AFTER_COMMIT）是先提交事务，再等待复制，这样会性能好一点，但是存在宕机丢数据的风险。\n如果主库提交事务的线程等待复制的时间超时了，那么这种情况下 MySQL 会自动降级为异步复制模式。\n一种优化方式是增强半同步复制——基于两阶段提交的优化。\n两阶段提交是 MySQL 用于利用类似分布式 XA 两阶段提交（分布式一致性的一种解决方法），解决 redo log 和 binlog 一致性的一种日志提交方式。\n增强半同步复制不同于普通的半同步复制，它的等待备库返回 ACK 的时间点是最后的 commit 之后（即图片中的步骤三之后）。步骤二生成 binlog 以后发给从库，从库对得到的 binlog 同步完毕以后主库进行步骤三 commit，然后认为同步完毕。 这样如果日志没有传给从库，主库也不会 commit，保障了数据同步一致性。\n主从延迟 主从延迟指的是从主库生成 binlog 到从库接收到 binlog 然后执行完对应的事务之间的延迟。\n主从延迟的原因主要有以下几点：\n网络延迟：主从之间网络延迟越长，主从延迟就越大。 某些情况下，从库的机器性能比主库的机器性能差。 从库的读压力过大 慢 sql、大事务造成的时间等待，binlog 生成速度慢，导致从库延迟。 针对主从同步的延迟，有一些可靠性和可用性的策略调整，如双 M（两个主机）、半同步复制等针对主从的调度策略，会减少主从延迟。\n分库分表 分库分表主要是为了解决两个问题：解决查询慢的问题，解决高并发的问题。\n解决查询慢的问题，其实只需要减少每次查询时检索的数据量就行了。例如：即使数据量很大的情况，如果能走索引，那么查询扫描的次数也很少，并不需要全表扫描检索很多次，所以性能也很好。当然我们考虑的肯定是不全能走索引的情况，那么除了建立合适的索引之外，还可以考虑分表。只需要将查询的数据分散到多个表中，每次查询对应的表，这样检索的数据就变少了，查询效率也变快了。\n解决高并发的问题，这就需要分库了。因为有时候查询的压力过大，并发量过多，一个数据库实例就容易扛不住导致宕机。通过分库的方式，就可以把并发请分散到多个实例中，从而缓解一个实例的压力。\n分库分表一般垂直和水平两种，一般来讲，垂直分库分表主要是将原来一张表里面的字段拆分开，分散到多个表中，其目的是加快查询效率，减少一些不必要的字段。水平分库分表主要是为了将数据分散开，一般会选择某种哈希算法，针对表的 id 进行水平划分，起到负载均衡的作用。水平分库分表也是解决海量存储的一种策略，即使是走索引的查询，数据量少了也会减少磁盘 IO 次数，从而加快查询效率。\nRedis 像 MySQL 的同步基于 binlog 一样，Redis 的同步也是基于日志的。主要有 AOF（Append Only File）和 RDB（Redis DataBase）两种方式。AOF 是 Redis 在每行数据操作以后记录同样的操作语句，而 RDB 是内存快照。当然也各有利弊，这里不在赘述。\nRedis 的集群主要有主从集群、哨兵集群、切片集群等模式，其目的都是为了保证 Redis 的高可用性。\n主从集群 主从集群是 Redis 的一种集群模式，其原理是主节点负责写数据，从节点负责读数据。主节点将数据同步到从节点，从节点通过读取主节点的数据来获取最新的数据，类似于 MySQL 的主从集群。\n主从同步主要有三个阶段：\n连接阶段：从库给主库发送 psync 命令表示要进行同步，里面包括的了主库的 runID 和复制进度 offset（第一次为-1）。主库收到收到以后会返回 FULLRESYNC 命令，并带上主库的 runID 和 offset。（第一次全量复制） 主从集群的优点是数据复制简单，缺点是数据不一致。如果主节点挂掉，从节点只能提供只读服务。\n哨兵集群 参考文献 多图文，详细介绍 mysql 各个集群方案 MySQL 中常见的几种高可用架构部署方案 MySQL 日志：undo log、redo log、binlog 有什么用？ MySQL 半同步复制及半同步复制增强 ","wordCount":"256","inLanguage":"zh","datePublished":"2025-02-07T19:52:18+08:00","dateModified":"2025-02-07T19:52:18+08:00","author":{"@type":"Person","name":"Airplane"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://vinci-217.github.io/blog/database-cluster/"},"publisher":{"@type":"Organization","name":"Airplane Space","logo":{"@type":"ImageObject","url":"https://vinci-217.github.io/favicon.ico"}}}</script><link rel=icon href=/images/airplane.jpg sizes=16x16><link rel=apple-touch-icon href=/images/airplane.jpg><link rel=manifest href=/images/airplane.jpg><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.ec28f09e946fc0df77c187fcd0d0ebde58fca6de8efb8e1620f3d45c32d4da88.css integrity="sha256-7CjwnpRvwN93wYf80NDr3lj8pt6O+44WIPPUXDLU2og=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.c607d6febd16934a82eb61d3a896ed9d869f54373cc63ce95864ed5488fe3128.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>主页
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/archive>归档</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/contact>联系</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/vinci-217><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span>
<span class=toggle-light><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>一文归纳数据库集群技术要点</h1></header><p><small>2025年2月7日&nbsp;· 256 字&nbsp;· 2 分钟</small>
<small>·
<a href=https://vinci-217.github.io/tags/mysql/>MySQL</a>
<a href=https://vinci-217.github.io/tags/redis/>Redis</a>
<a href=https://vinci-217.github.io/tags/cluster/>Cluster</a></small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#mysql>MySQL</a><ul><li><a href=#读写分离>读写分离</a></li><li><a href=#集群模式>集群模式</a></li><li><a href=#主从同步>主从同步</a></li><li><a href=#主从延迟>主从延迟</a></li><li><a href=#分库分表>分库分表</a></li></ul></li><li><a href=#redis>Redis</a><ul><li><a href=#主从集群>主从集群</a></li><li><a href=#哨兵集群>哨兵集群</a></li></ul></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div><section class=blog-content><p>数据库是服务端开发离不开的中间件，为了提高大型项目中数据库的可用性，常常通过集群的方式部署数据库。本文将从数据库集群的技术要点出发，介绍基于 MySQL 和 Redis 的数据库集群方案。</p><h2 id=mysql>MySQL</h2><p>MySQL 最初是一种单机的数据库系统，他的集群出现主要是为了应对高并发读写和数据库宕机的场景。针对这样的场景，MySQL 采用了多个服务集群部署、读写分离等策略来应对。MySQL 集群的方式有很多种，目的都是为了提高其可用性。</p><h3 id=读写分离>读写分离</h3><p>读写分离是提高 MySQL 并发量的一种策略，其含义是使用多个具有相同数据的 MySQL 实例来分担大量查询请求。其本质上是有一个或多个主节点作为客户端写入的实例，其他的实例作为备份节点，提供只读的服务。</p><p>读写分离本质上相当于一种请求的负载均衡，将读请求分担到多个从节点，将写请求分担到主节点。但也会面临一些集群的问题。根据经典的 CAP 理论，网络分区容忍性必须保证，那么一致性和可用性就成为一个值得权衡的点。最明显的就是由于主从同步的延迟，可能会出现数据不一致的问题。</p><p><img src=image/image.png alt="MySQL 集群架构"></p><h3 id=集群模式>集群模式</h3><h4 id=mysql-replication>MySQL Replication</h4><p>MySQL Replication 最基本的 MySQL 集群功能，基于一主多从的架构，主库负责写数据，从库负责读数据。主库会将数据变更记录在 binlog 中，从库通过读取主库的 binlog 来获取主库的最新数据，相当于主库的 sql 语句在从库上又执行了一遍。</p><h4 id=mysql-fabirc>MySQL Fabirc</h4><p>MySQL Fabric 是在 MySQL Replication 的基础上，增加的故障检测与转移、自动数据分片的功能。但是依然是基于一主多从的架构，主库负责写数据，从库负责读数据。MySQL Fabric 只有一个主节点，但是当主节点挂掉以后，会从从节点中选一个来当主节点。</p><h4 id=mysql-cluster>MySQL Cluster</h4><p>MySQL Cluster 是一种多主多从的架构，也是由 MySQL 官方提供。他的高可用、负载均衡、伸缩性都很优秀，但是架构模式和原理很复杂，并且只能使用 NDB 存储引擎而不是 InnoDB 存储引擎（比如在事务隔离级别上只支持 Read Committed）。</p><h3 id=主从同步>主从同步</h3><p>MySQL 的集群之间的数据同步是基于 binlog 的。binlog 是 MySQL 服务器的二进制日志，记录了对数据库的修改，包括增删改操作。通过 binlog，可以将数据同步到其他的 MySQL 服务器，实现数据库集群的数据一致性。</p><p>binlog 有三种格式，一种是 statement，一种是 row，还有一种是 mixed。statement 格式的 binlog 记录的是 SQL 语句的原始文本，row 格式的 binlog 记录的是每行数据的修改，mixed 格式的 binlog 既记录 SQL 语句，又记录每行数据的修改。</p><p>假如我们执行一个删除的 SQL，<code>delete from table1 where id > 100 limit 1</code>，由于 limit 这个命令，可能导致从库具体的这个 limit 1 和主库的 limit 1 不是同一行数据，所以造成误删的风险，那么 row 格式的 binlog 就应运而生了。但是由于每次记录 row 类型的 binlog 对内存开销太大，所以就有了 mixed 格式的 binlog——既记录 SQL 语句，又记录每行数据的修改，做了两者之间的权衡。</p><p>不同的集群模式主从同步的方式也不太一样，但大致流程相似：</p><ol><li>主库接收到客户端的更新请求，执行更新操作并写入 binlog</li><li>从库在主从之间简历长连接</li><li>主库的 dump_tread 从本地读取 binlog 给从库</li><li>从库获取到主库的 binlog 后存储到本地，成为 relay log</li><li>从库的 sql_thread 读取 relay log，解析出具体的 sql 语句，执行 sql 语句</li></ol><p>主从库之间的数据借助 binlog 进行复制，数据复制的一般分为同步和异步两种。同步复制就是主库接收到写请求完成以后，会等待副本的写请求也完成，才返回客户端，而异步复制就是主库直接返回客户端，不等待副本的写请求完成，然后让异步线程去处理副本的写请求。很经典的问题出现了：同步复制能够很好保证数据一致性，但是性能差；异步复制反之。</p><p>其实除了我们讨论的主从复制，还有多主复制、无主复制等演化得到的不同的主从模型，此处就不在深入讨论了。</p><p>MySQL 5.7 版本引入了半同步复制。异步复制是事务线程完全不等复制响应。同步复制是事务线程要等所有复制响应。半同步复制就是等待一部分复制响应就认为成功。</p><p>比较重要的是半同步复制。</p><p>半同步复制过程中有一个参数“rpl_semi_sync_master_wait_no_slave”，默认值是 1，表示等待至少一个从库的响应，如果设置为大于 1 的值，表示等待指定数量的从库的响应。</p><p>还有一个是”rpl_semi_sync_master_wait_point“，表示的是主库提交事务之前等待复制还是提交事务之后等待复制。，默认是先等待复制（AFTER_SYNC），再提交事务，这样不会完全丢数据。相反的配置（AFTER_COMMIT）是先提交事务，再等待复制，这样会性能好一点，但是存在宕机丢数据的风险。</p><p>如果主库提交事务的线程等待复制的时间超时了，那么这种情况下 MySQL 会自动降级为异步复制模式。</p><p>一种优化方式是增强半同步复制——基于两阶段提交的优化。</p><p><a href=https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84>两阶段提交</a>是 MySQL 用于利用类似分布式 XA 两阶段提交（分布式一致性的一种解决方法），解决 redo log 和 binlog 一致性的一种日志提交方式。</p><p><img src=image/image-1.png alt=两阶段提交></p><p>增强半同步复制不同于普通的半同步复制，它的等待备库返回 ACK 的时间点是最后的 commit 之后（即图片中的步骤三之后）。步骤二生成 binlog 以后发给从库，从库对得到的 binlog 同步完毕以后主库进行步骤三 commit，然后认为同步完毕。
这样如果日志没有传给从库，主库也不会 commit，保障了数据同步一致性。</p><h3 id=主从延迟>主从延迟</h3><p>主从延迟指的是从主库生成 binlog 到从库接收到 binlog 然后执行完对应的事务之间的延迟。</p><p>主从延迟的原因主要有以下几点：</p><ol><li>网络延迟：主从之间网络延迟越长，主从延迟就越大。</li><li>某些情况下，从库的机器性能比主库的机器性能差。</li><li>从库的读压力过大</li><li>慢 sql、大事务造成的时间等待，binlog 生成速度慢，导致从库延迟。</li></ol><p>针对主从同步的延迟，有一些可靠性和可用性的策略调整，如双 M（两个主机）、半同步复制等针对主从的调度策略，会减少主从延迟。</p><h3 id=分库分表>分库分表</h3><p>分库分表主要是为了解决两个问题：解决查询慢的问题，解决高并发的问题。</p><p>解决查询慢的问题，其实只需要减少每次查询时检索的数据量就行了。例如：即使数据量很大的情况，如果能走索引，那么查询扫描的次数也很少，并不需要全表扫描检索很多次，所以性能也很好。当然我们考虑的肯定是不全能走索引的情况，那么除了建立合适的索引之外，还可以考虑<strong>分表</strong>。只需要将查询的数据分散到多个表中，每次查询对应的表，这样检索的数据就变少了，查询效率也变快了。</p><p>解决高并发的问题，这就需要<strong>分库</strong>了。因为有时候查询的压力过大，并发量过多，一个数据库实例就容易扛不住导致宕机。通过分库的方式，就可以把并发请分散到多个实例中，从而缓解一个实例的压力。</p><p>分库分表一般垂直和水平两种，一般来讲，垂直分库分表主要是将原来一张表里面的字段拆分开，分散到多个表中，其目的是加快查询效率，减少一些不必要的字段。水平分库分表主要是为了将数据分散开，一般会选择某种哈希算法，针对表的 id 进行水平划分，起到负载均衡的作用。水平分库分表也是解决海量存储的一种策略，即使是走索引的查询，数据量少了也会减少磁盘 IO 次数，从而加快查询效率。</p><h2 id=redis>Redis</h2><p>像 MySQL 的同步基于 binlog 一样，Redis 的同步也是基于日志的。主要有 AOF（Append Only File）和 RDB（Redis DataBase）两种方式。AOF 是 Redis 在每行数据操作以后记录同样的操作语句，而 RDB 是内存快照。当然也各有利弊，这里不在赘述。</p><p>Redis 的集群主要有主从集群、哨兵集群、切片集群等模式，其目的都是为了保证 Redis 的高可用性。</p><h3 id=主从集群>主从集群</h3><p>主从集群是 Redis 的一种集群模式，其原理是主节点负责写数据，从节点负责读数据。主节点将数据同步到从节点，从节点通过读取主节点的数据来获取最新的数据，类似于 MySQL 的主从集群。</p><p>主从同步主要有三个阶段：</p><ol><li>连接阶段：从库给主库发送 psync 命令表示要进行同步，里面包括的了主库的 runID 和复制进度 offset（第一次为-1）。主库收到收到以后会返回 FULLRESYNC 命令，并带上主库的 runID 和 offset。（第一次全量复制）</li><li></li></ol><p>主从集群的优点是数据复制简单，缺点是数据不一致。如果主节点挂掉，从节点只能提供只读服务。</p><h3 id=哨兵集群>哨兵集群</h3><h2 id=参考文献>参考文献</h2><ul><li><a href=https://www.cnblogs.com/lgx211/p/12456859.html>多图文，详细介绍 mysql 各个集群方案</a></li><li><a href=https://www.cnblogs.com/ricklz/p/17335755.html>MySQL 中常见的几种高可用架构部署方案</a></li><li><a href=https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84>MySQL 日志：undo log、redo log、binlog 有什么用？</a></li><li><a href=https://juejin.cn/post/6981745007552102407>MySQL 半同步复制及半同步复制增强</a></li></ul></section><div class=paginator><a class=prev href=https://vinci-217.github.io/blog/mq/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg>
<span>深入探究主流消息队列技术选型与实践</span></a>
<a class=next href=https://vinci-217.github.io/blog/rate-limit/><span>详解几种常见限流算法及限流器设计</span><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M12.055 9C12.711 9.61644 14.3679 10.997 15.9519 11.7966 16.0174 11.8297 16.0154 11.9753 15.9494 12.0063 14.945 12.4779 13.0706 13.9264 12.055 15m3.5006-3.0333C13.1345 12.0608 8 12 6 11" stroke="currentcolor" stroke-linecap="round"/></svg></a></div><div class=comments><script>const getTheme=window.localStorage&&window.localStorage.getItem("theme");let theme=getTheme==="dark"?"dark":"light",s=document.createElement("script");s.src="https://giscus.app/client.js",s.setAttribute("data-repo","vinci-217/vinci-217.github.io"),s.setAttribute("data-repo-id","R_kgDONs9UyA"),s.setAttribute("data-category","Announcements"),s.setAttribute("data-category-id","DIC_kwDONs9UyM4CmMmz"),s.setAttribute("data-mapping","pathname"),s.setAttribute("data-strict","0"),s.setAttribute("data-reactions-enabled","1"),s.setAttribute("data-emit-metadata","0"),s.setAttribute("data-input-position","top"),s.setAttribute("data-theme",theme),s.setAttribute("data-lang",""),s.setAttribute("data-loading","lazy"),s.setAttribute("crossorigin","anonymous"),s.setAttribute("async",""),document.querySelector("div.comments").innerHTML="",document.querySelector("div.comments").appendChild(s)</script></div></article></div><footer class=footer><p>&copy; 2025 <a href=https://vinci-217.github.io/>Airplane Space</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg>
</a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>const images=Array.from(document.querySelectorAll(".blog-content img"));images.forEach(e=>{mediumZoom(e,{margin:10,scrollOffset:40,container:null,template:null,background:"rgba(0, 0, 0, 0.5)"})})</script><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>