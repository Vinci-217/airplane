<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Airplane Space</title><link>https://vinci-217.github.io/blog/</link><description>Recent content in Blogs on Airplane Space created by</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 01 Feb 2025 10:30:31 +0800</lastBuildDate><atom:link href="https://vinci-217.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>详解几种常见限流算法及限流器设计</title><link>https://vinci-217.github.io/blog/rate-limit/</link><pubDate>Sat, 01 Feb 2025 10:30:31 +0800</pubDate><guid>https://vinci-217.github.io/blog/rate-limit/</guid><description>&lt;p>在服务端开发中，限流（Rate Limiting）是一种常见的技术，用于控制请求的流量，防止请求过多导致服务器压力过大或响应时间过长。限流算法有很多种，本文将介绍主要的几种常见限流算法及限流器设计。&lt;/p>
&lt;h2 id="限流场景">限流场景&lt;/h2>
&lt;p>在实际开发过程中，我们需要考虑一些需要限流的场景。比如防止突发流量激增导致服务崩溃，或者防止恶意请求导致服务器资源占用过多，又或者某些业务场景下我们需要限制用户的请求频率。&lt;/p>
&lt;p>衡量请求频率的指标主要有两种：&lt;/p>
&lt;p>TPS: 每秒事务数（Transaction Per Second）&lt;/p>
&lt;p>TPS 代表每秒事务数，是衡量系统处理能力的一个指标。事务通常指的是一组操作的集合，可能包括多个数据库操作、消息队列处理等。在许多情况下，TPS 用于衡量数据库系统或应用程序在特定负载下的性能。&lt;/p>
&lt;p>QPS: 每秒查询数（Query Per Second）&lt;/p>
&lt;p>QPS 代表每秒查询数，是衡量系统查询能力的一个指标。查询通常指的是数据库查询操作，包括 SELECT、INSERT、UPDATE、DELETE 等。在许多情况下，QPS 用于衡量数据库系统或应用程序的查询性能。&lt;/p>
&lt;p>在某些系统中，一个事务可能包含多个查询，因此在这些情况下，TPS 和 QPS 之间可以有一定的关系。例如，一个事务包含三个查询，那么在理想情况下，QPS 可能是 TPS 的三倍。&lt;/p>
&lt;h2 id="限流算法">限流算法&lt;/h2>
&lt;h3 id="基于计数器的限流">基于计数器的限流&lt;/h3>
&lt;p>基于计数器的限流算法理解起来很容易。我们只需要维护一个计数器，然后每一分钟的开始重置计数器为 0，然后在这一分钟内如果计数器超过了某个阈值，那么对于超出阈值的请求直接拒绝，这样就实现了基于计数器的限流。&lt;/p>
&lt;p>&lt;img src="image/image.png" alt="计数器限流">&lt;/p>
&lt;p>实现这样的限流很简单，但是问题也很明显：有时候请求可能会在前一秒的末尾和后一秒的开始突然出现某个阈值的流量，而根据我们队限流算法的设计，这样的请求是被允许的。但是这样的话对于 0.9s 到 1.1s 之间的流量就超过了我们设定的阈值，这样导致的瞬时流量也会对服务造成压力。所以有了滑动窗口算法。&lt;/p>
&lt;p>&lt;img src="image/image-1.png" alt="计数器限流问题">&lt;/p>
&lt;h3 id="基于滑动窗口的限流">基于滑动窗口的限流&lt;/h3>
&lt;p>基于滑动窗口的限流算法是基于计数器的限流算法的改进。它将限流的时间窗口分为多个小窗口，然后在每个小窗口内独立维护一个计数器，当计数器超过了某个阈值，那么对于超出阈值的请求直接拒绝。随着时间的推移，每次都会排除掉过去最近的一个小窗口，然后引入最新的一个小窗口。相比于基于计数器的限流，基于滑动窗口的限流算法每次推移的单位是一个小窗口区间，而不是一个大时间区间，这样就实现了更精确的时间片限流。&lt;/p>
&lt;p>&lt;img src="image/image-2.png" alt="滑动窗口限流">&lt;/p>
&lt;p>但是即是通过滑动窗口算法人为将时间分成了比较小的片，也依然有可能在时间区间内发生突发且不均匀的流量，可能压垮服务。但是如果小将片划分的足够小，又可能会带来系统的损耗和性能的问题。&lt;/p>
&lt;h3 id="漏桶算法">漏桶算法&lt;/h3>
&lt;p>漏桶算法的实现原理类似于缓冲。不管请求是怎么来的，都直接放到桶里面。然后桶里面的请求以固定的速度流出。如果流量过多或者过大超出了桶的容量，那么就丢弃一些请求，桶里面的请求以固定的速度流出。&lt;/p>
&lt;p>&lt;img src="image/image-3.png" alt="漏桶算法">&lt;/p>
&lt;p>最常见的模拟漏桶算法的方式就是 FIFO 的消息队列。请求会被放到队列中，等待被服务消费。&lt;/p>
&lt;p>漏桶算法可以实现流量的平滑处理，但是如果突然来了很多流量，那么桶一下就被填满了。由于流出的速率是恒定的，所以当短时间有大量的突发请求到了桶里面，那么每个请求也得等一段时间才能被相应。所以漏桶算法无法应对突发流量。&lt;/p>
&lt;h3 id="令牌桶算法">令牌桶算法&lt;/h3>
&lt;p>相较于漏桶算法，令牌桶算法可以更好的处理突发流量。每到一个请求，必须先去令牌桶里面申请令牌。申请到的令牌才会被服务器处理，否则就会拒绝。&lt;/p>
&lt;p>&lt;img src="image/image-4.png" alt="令牌桶算法">&lt;/p>
&lt;p>在请求较低的时候，令牌数量会被慢慢增加，一直到达到桶的最大容量。在遇到突发流量时，令牌桶内会有一定的令牌数。新到达的请求会申请这些令牌且不会被拒绝，这样就有了当面对突发流量时的应对能力。&lt;/p>
&lt;p>令牌桶算法当然可以基于队列实现，这样比较直观。我们也可以直接用时间的方式去实现，这样就不用在内存中维护队列了。&lt;/p>
&lt;p>两个简单的获取令牌的实现示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.atomic.AtomicInteger;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.Executors;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.ScheduledExecutorService;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.TimeUnit;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">TokenBucketRateLimiter&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> bucketCapacity; &lt;span style="color:#75715e">// 令牌桶的容量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> refillRate; &lt;span style="color:#75715e">// 令牌生成速率（每秒生成的令牌数）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> AtomicInteger tokens; &lt;span style="color:#75715e">// 当前令牌数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">TokenBucketRateLimiter&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> bucketCapacity, &lt;span style="color:#66d9ef">int&lt;/span> refillRate) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">bucketCapacity&lt;/span> &lt;span style="color:#f92672">=&lt;/span> bucketCapacity;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">refillRate&lt;/span> &lt;span style="color:#f92672">=&lt;/span> refillRate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">this&lt;/span>.&lt;span style="color:#a6e22e">tokens&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> AtomicInteger(0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> startRefilling(); &lt;span style="color:#75715e">// 启动定期生成令牌的线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 尝试获取一个令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">tryAcquire&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> currentTokens &lt;span style="color:#f92672">=&lt;/span> tokens.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (currentTokens &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tokens.&lt;span style="color:#a6e22e">compareAndSet&lt;/span>(currentTokens, currentTokens &lt;span style="color:#f92672">-&lt;/span> 1)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;请求获得令牌，允许通过&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;请求被拒绝：无可用令牌&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 定期为令牌桶添加令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">startRefilling&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ScheduledExecutorService executor &lt;span style="color:#f92672">=&lt;/span> Executors.&lt;span style="color:#a6e22e">newScheduledThreadPool&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> executor.&lt;span style="color:#a6e22e">scheduleAtFixedRate&lt;/span>(() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> currentTokens &lt;span style="color:#f92672">=&lt;/span> tokens.&lt;span style="color:#a6e22e">get&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (currentTokens &lt;span style="color:#f92672">&amp;lt;&lt;/span> bucketCapacity) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> newTokens &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">min&lt;/span>(bucketCapacity, currentTokens &lt;span style="color:#f92672">+&lt;/span> refillRate);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tokens.&lt;span style="color:#a6e22e">set&lt;/span>(newTokens);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;新增令牌，当前令牌数：&amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> newTokens);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, 0, 1, TimeUnit.&lt;span style="color:#a6e22e">SECONDS&lt;/span>); &lt;span style="color:#75715e">// 每秒填充令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TokenBucketRateLimiter rateLimiter &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> TokenBucketRateLimiter(10, 2); &lt;span style="color:#75715e">// 容量为10，每秒生成2个令牌&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 模拟10个请求&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 10; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> allowed &lt;span style="color:#f92672">=&lt;/span> rateLimiter.&lt;span style="color:#a6e22e">tryAcquire&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>allowed) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;请求 &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; 被拒绝&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">sleep&lt;/span>(200); &lt;span style="color:#75715e">// 模拟请求间隔&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (InterruptedException e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.&lt;span style="color:#a6e22e">currentThread&lt;/span>().&lt;span style="color:#a6e22e">interrupt&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">ratelimit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;sync&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">RateLimiter&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rate&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 令牌放入速度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 令牌最大数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">last&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 上一次请求发生时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span> &lt;span style="color:#75715e">// 令牌数量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">lock&lt;/span> &lt;span style="color:#a6e22e">sync&lt;/span>.&lt;span style="color:#a6e22e">Mutex&lt;/span> &lt;span style="color:#75715e">// 由于读写冲突，需要加锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获得当前时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">cur&lt;/span>() &lt;span style="color:#66d9ef">int64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>().&lt;span style="color:#a6e22e">Unix&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#a6e22e">rate&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>, &lt;span style="color:#a6e22e">max&lt;/span> &lt;span style="color:#66d9ef">int64&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RateLimiter&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TODO: 检查一下rate和max是否合法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">RateLimiter&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rate&lt;/span>: &lt;span style="color:#a6e22e">rate&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">max&lt;/span>: &lt;span style="color:#a6e22e">max&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">last&lt;/span>: &lt;span style="color:#a6e22e">cur&lt;/span>(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amount&lt;/span>: &lt;span style="color:#a6e22e">max&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">rl&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">RateLimiter&lt;/span>) &lt;span style="color:#a6e22e">Pass&lt;/span>() &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">lock&lt;/span>.&lt;span style="color:#a6e22e">Lock&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">lock&lt;/span>.&lt;span style="color:#a6e22e">Unlock&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 距离上一次请求过去的时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">passed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">cur&lt;/span>() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;passed is: &amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">passed&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算在这段时间里 令牌数量可以增加多少&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">passed&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">rate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果令牌数量超过上限；我们就不继续放入那么多令牌了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">amount&lt;/span> &amp;gt; &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">max&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amount&lt;/span> = &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">max&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 如果令牌数量仍然小于0，则说明请求应该拒绝&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">amount&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 请求被放行则令牌数-1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">amount&lt;/span>&lt;span style="color:#f92672">--&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">amount&lt;/span> = &lt;span style="color:#a6e22e">amount&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 更新上次请求时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">rl&lt;/span>.&lt;span style="color:#a6e22e">last&lt;/span> = &lt;span style="color:#a6e22e">cur&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="限流器设计">限流器设计&lt;/h2>
&lt;p>如果我们要设计一个限流器，通常要考虑下面几个方面资源的限流：&lt;/p>
&lt;ol>
&lt;li>全局接口限流&lt;/li>
&lt;li>用户的账号限流&lt;/li>
&lt;li>某请求限流&lt;/li>
&lt;li>设备限流&lt;/li>
&lt;/ol>
&lt;p>限流器通常位于网关的部分，属于网关的一个过滤器，通过责任链模式进行校验后转发到后端服务。&lt;/p>
&lt;p>限流的模式有本地限流和远程限流两种：本地限流和远程限流。&lt;/p>
&lt;p>本地限流就是每个网关服务器自身进行限流。网关直接亦为集群负载均衡部署，假设每个网关限流为 100 的 QPS，那么 10 个网关集群的 QPS 大约为 1000。&lt;/p>
&lt;p>远程限流就是通过远程服务进行限流，比如通过配置中心或者 Redis 进行限流。远程限流亦需要考虑 Redis 的可用性和集群数据一致性。&lt;/p>
&lt;p>同时我们还需要考虑限流的高可用性：当远程限流不可用时，亦需要降级为本地限流。&lt;/p>
&lt;p>除此以外我们就需要考虑限流算法的选用。一般企业界选用的限流算法为令牌桶算法，即能够应对突发流量，也能够平滑流量。&lt;/p>
&lt;h2 id="guava-中限流的实现">Guava 中限流的实现&lt;/h2>
&lt;h2 id="拓展延伸">拓展延伸&lt;/h2>
&lt;p>其实限流保护的策略不仅仅在后端服务上，有时候在产品本身的设计上也可以考虑。比如 12306 在抢票购票设计时，会将不同车次的购买时间分隔开，以及提前一定时间前购票。从产品的角度，避免了某一个时间突然的高并发，反而将流量相对的均匀开，也是一种不错的在流量方面的保护策略。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>&lt;img src="https://www.bilibili.com/list/watchlater?oid=113793128465727&amp;amp;bvid=BV1NTrvYnEbM&amp;amp;spm_id_from=333.1007.top_right_bar_window_view_later.content.click" alt="【java面试加分项】12306超高并发如何保证数据一致性？">
&lt;img src="https://blog.csdn.net/qq_42055933/article/details/143694116" alt="Java实现令牌桶算法：详细讲解与代码示例">
&lt;img src="https://github.com/wfnuser/Algorithms" alt="极客时间令牌桶算法代码">&lt;/p></description></item><item><title>深入理解分布式锁的原理和技术选型</title><link>https://vinci-217.github.io/blog/lock/</link><pubDate>Wed, 22 Jan 2025 10:28:35 +0800</pubDate><guid>https://vinci-217.github.io/blog/lock/</guid><description>&lt;p>分布式锁是一种常用的技术，在分布式环境下，为了避免多个进程或线程同时操作同一资源造成冲突，引入分布式锁机制。本文将介绍分布式锁的原理和使用场景，并通过 Redis、Zookeeper、Redisson 等中间件来实现分布式锁。&lt;/p>
&lt;h2 id="分布式锁的主要特性">分布式锁的主要特性&lt;/h2>
&lt;ul>
&lt;li>互斥：不同线程之间互斥，只有一个线程能持有锁。&lt;/li>
&lt;li>超时机制：代码耗时过长，网络原因等，导致锁一直被占用，造成死锁，所以引入超时机制，超过指定时间自动释放锁。&lt;/li>
&lt;li>可重入性：当前请求的节点 + 线程唯一标识，可以再次获取同一把锁&lt;/li>
&lt;li>公平性：锁唤醒时候，按照顺序唤醒，不公平的话，有可能出现饥饿现象。&lt;/li>
&lt;/ul>
&lt;h2 id="分布式锁的原理与实现">分布式锁的原理与实现&lt;/h2>
&lt;p>分布式锁的目的是区别于 JVM 单机锁。&lt;/p>
&lt;p>JVM 单机锁就是在同一个 JVM 中的锁。比如你使用了 synchronized 关键字，那么就是在这同一个 JVM 中，同一时刻只能有一个线程持有锁，其他线程只能等待。但是当你的后端服务是分布式集群部署的方式，那么 JVM 单机锁就无法满足需求了。因为你这个 JVM 锁住了，我的线程打到了另一台机器上，那就相当于没锁住，所以我们需要分布式锁。分布式锁的目的就是在多个 JVM 层之前设置的锁，这样就可以在多个机器上实现同一把锁的目的。&lt;/p>
&lt;p>&lt;img src="image/image-3.png" alt="alt text">&lt;/p>
&lt;p>分布式锁的原理就是在多个机器上设置同一把锁，这个锁通常通过某些中间件实现。当一个线程想要获取锁的时候，首先会去尝试获取锁，如果获取成功，那么就可以执行任务，如果获取失败，那么就只能等待，直到锁被释放。&lt;/p>
&lt;h3 id="mysql">MySQL&lt;/h3>
&lt;h4 id="基于索引">基于索引&lt;/h4>
&lt;p>基于索引的实现，是通过在数据库的某个字段上加了唯一的索引，那么只有一个线程能够对写入同一个数据，其他的线程由于索引的唯一性而无法写入，只能等待资源释放——这个唯一值被 DELETE 掉，那么可以重新写入来获取锁&lt;/p>
&lt;p>我们可以先创建一个类似的表：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>database_lock&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> BIGINT &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> AUTO_INCREMENT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>resource&lt;span style="color:#f92672">`&lt;/span> int &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;锁定的资源&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>description&lt;span style="color:#f92672">`&lt;/span> varchar(&lt;span style="color:#ae81ff">1024&lt;/span>) &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;描述&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">UNIQUE&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>uiq_idx_resource&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>resource&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) ENGINE&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> CHARSET&lt;span style="color:#f92672">=&lt;/span>utf8mb4 &lt;span style="color:#66d9ef">COMMENT&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;数据库分布式锁表&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的 resource 就是锁的名字，locked_at 就是锁的创建时间。&lt;/p>
&lt;p>这里我们给数据库加了一个唯一索引，目的是对资源进唯一性约束。这样在写入同一个数据时，只能有一个线程写入，其他线程只能失败。通过这样的方法就实现了一个分布式锁。&lt;/p>
&lt;p>这种锁的实现比较简单，但也会面临锁无法过期，锁的可靠性依赖于 MySQL 数据库的可用性等等问题。&lt;/p>
&lt;h4 id="基于乐观锁">基于乐观锁&lt;/h4>
&lt;p>基于乐观锁的实现原理是多个线程可以同时对资源进行修改，但最终只能有一个修改成功，其他的回退。乐观锁的实现一般是基于版本号的机制，比如在更新数据时，先获取当前版本号，然后更新数据，再更新版本号。如果更新失败，说明数据已经被其他线程更新过了，那么就需要重试。&lt;/p>
&lt;p>例如建立如下的数据库表：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> &lt;span style="color:#f92672">`&lt;/span>optimistic_lock&lt;span style="color:#f92672">`&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span> BIGINT &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> AUTO_INCREMENT,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>resource&lt;span style="color:#f92672">`&lt;/span> int &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;锁定的资源&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>&lt;span style="color:#66d9ef">version&lt;/span>&lt;span style="color:#f92672">`&lt;/span> int &lt;span style="color:#66d9ef">NOT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span> &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;版本信息&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>created_at&lt;span style="color:#f92672">`&lt;/span> datetime &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;创建时间&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>updated_at&lt;span style="color:#f92672">`&lt;/span> datetime &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;更新时间&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">`&lt;/span>deleted_at&lt;span style="color:#f92672">`&lt;/span> datetime &lt;span style="color:#66d9ef">COMMENT&lt;/span> &lt;span style="color:#e6db74">&amp;#39;删除时间&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PRIMARY&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>id&lt;span style="color:#f92672">`&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">UNIQUE&lt;/span> &lt;span style="color:#66d9ef">KEY&lt;/span> &lt;span style="color:#f92672">`&lt;/span>uiq_idx_resource&lt;span style="color:#f92672">`&lt;/span> (&lt;span style="color:#f92672">`&lt;/span>resource&lt;span style="color:#f92672">`&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) ENGINE&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> CHARSET&lt;span style="color:#f92672">=&lt;/span>utf8mb4 &lt;span style="color:#66d9ef">COMMENT&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;数据库分布式锁表&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每个线程的执行逻辑如下：&lt;/p>
&lt;ul>
&lt;li>获取资源： SELECT resource, version FROM optimistic_lock WHERE id = 1&lt;/li>
&lt;li>执行业务逻辑&lt;/li>
&lt;li>更新资源：UPDATE optimistic_lock SET resource = resource -1, version = version + 1 WHERE id = 1 AND version = oldVersion&lt;/li>
&lt;/ul>
&lt;p>通过比对修改后的 version 和修改之前的 oldVersion，如果一致，说明数据没有被其他线程更新过，那么就更新成功，否则就需要重试。&lt;/p>
&lt;p>这种锁的实现比较复杂，但也能保证数据的一致性。在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能。但是需要对表的设计增加额外的字段，增加了数据库的冗余。并且高并发的情况下增加了重试的次数，会影响性能。&lt;/p>
&lt;h4 id="基于悲观锁">基于悲观锁&lt;/h4>
&lt;p>基于悲观锁的实现原理是多个线程只能一个一个地获取锁，直到获取锁的线程释放锁，其他线程才能获取锁。我们在基于 MySQL 的悲观锁的实现中，一般采用 MySQL 自带的锁机制，比如 SELECT &amp;hellip; FOR UPDATE。数据库会在查询的过程中加上排他锁，那么这样别的事务就无法对该资源进行修改。&lt;/p>
&lt;p>基于悲观锁的实现过程如下：&lt;/p>
&lt;ul>
&lt;li>获取资源： SELECT * FROM optimistic_lock WHERE id = 1 FOR UPDATE&lt;/li>
&lt;li>执行业务逻辑&lt;/li>
&lt;li>释放资源：COMMIT&lt;/li>
&lt;/ul>
&lt;p>相当于我们基于 SELECT &amp;hellip; FOR UPDATE 获取了这行数据的锁，并且在同一事务下执行修改的业务逻辑，最终在 COMMIT 提交事务时释放锁。&lt;/p>
&lt;p>这种锁的的实现也比较简单，主要是基于数据库的事务和行锁。但要注意行锁失效的情况。并且每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。&lt;/p>
&lt;h3 id="zookeeper">Zookeeper&lt;/h3>
&lt;p>基于 Zookeeper 的分布式锁，主要来自于 Zookeeper 的两个机制&lt;/p>
&lt;ul>
&lt;li>临时顺序节点机制&lt;/li>
&lt;/ul>
&lt;p>Zookeeper 的节点是一个类似于文件系统的目录结构，每个节点都可以设置临时顺序节点，也就是说，在创建节点时，可以指定一个顺序，然后 Zookeeper 会根据这个顺序来分配节点的唯一标识符。除此以外节点也可以被标记为持久节点，持久节点会一直存在直到主动删除。&lt;/p>
&lt;ul>
&lt;li>watch 机制&lt;/li>
&lt;/ul>
&lt;p>Zookeeper 的 watch 机制允许用户在指定的节点上注册一个监听器，当节点发生变化时，Zookeeper 会通知监听器，并触发监听器的回调函数。&lt;/p>
&lt;p>基于这两个机制，我们可以实现一个基于 Zookeeper 的分布式锁。&lt;/p>
&lt;p>我们首先建立一个父节点，这个父节点是一个持久节点，用来表示共享资源。然后在父节点下创建临时顺序节点，这个临时顺序节点用来标识当前获得锁的线程。最终在父节点之下建立了一个类似于队列的结构。然后判断当前节点是不是最小的节点，如果是最小的节点，那么就获取锁，否则就监听前一个节点的删除事件，直到获得锁。每次节点使用完共享资源，就会删除该节点，进而释放锁，后面的节点通过 watch 监听前一个节点的删除事件，获得锁。&lt;/p>
&lt;p>&lt;img src="image/image.png" alt="alt text">&lt;/p>
&lt;p>Zookeeper 实现分布式锁的好处就是可以实现顺序的公平锁。并且可以实现较强一致性，所有的操作都可以被保证是原子性的。假如某个节点宕机了，那么会自动释放锁，防止了死锁，提高了系统的可用性。&lt;/p>
&lt;p>但是坏处就是，节点的创建和销毁对性能开销比较大，在高并发的环境下可能有较大的性能问题。另外，Zookeeper 的 watch 机制也会增加系统的复杂度，需要考虑节点的删除和创建的时机，以及节点的连接状态等。&lt;/p>
&lt;h3 id="redis">Redis&lt;/h3>
&lt;p>用 Redis 实现分布式锁，利用的是 SETNX+EXPIRE 命令。&lt;/p>
&lt;p>SETNX 命令的作用是设置一个 key，当 key 不存在时，返回 1，如果 key 已经存在，返回 0。EXPIRE 命令的作用是设置一个 key 的过期时间，当 key 过期时，Redis 会自动删除该 key。&lt;/p>
&lt;p>一般这两条命令写在一行来确保指令的原子性，如：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-redis" data-lang="redis">SETNX lock_key some_unique_value EXPIRE lock_key 10 # 设置过期时间为10秒
&lt;/code>&lt;/pre>&lt;p>其中 lock_key 是锁的名字，some_unique_value 是唯一的值，10 是过期时间。&lt;/p>
&lt;p>通常我们会在加锁的过程中，对 value 设置一个唯一的 UUID。当解锁的时候，我们会判断当前线程的这个 UUID 是否和锁的 value 一样，如果一样才能解锁。这样可以防止其他线程对锁进行误操作。&lt;/p>
&lt;p>解锁的过程通常分为：获取锁变量，检查锁变量的 value 是否和当前线程的 UUID 一致，如果一致则删除变量。通常为了保证解锁过程的原子性，我们会对这个操作进行 Lua 脚本的封装。&lt;/p>
&lt;p>当两个线程同时执行这个命令时，只有一个线程会成功对 lock_key 的值进行修改，其他线程会失败，这样就达到了分布式锁的目的。&lt;/p>
&lt;p>基于 Redis 实现分布式锁，由于是对值的修改，性能比较高。但是如果是在 Redis 集群环境下，由于 Redis 集群同步是异步的。如果在 Master 节点上设置锁，Slave 节点可能没有同步到最新的数据。此时 Master 节点崩溃了但是理论上锁不应当被释放，但由于 Master 的宕机导致了锁物理上被释放，所以其他客户端可能会加新的锁来对共享资源进行修改，这样就出现了问题。&lt;/p>
&lt;p>解决这个问题的方法就是 RedLock 算法——也就是 Redisson 的实现原理。&lt;/p>
&lt;h3 id="redisson">Redisson&lt;/h3>
&lt;p>用 Redisson 实现分布式锁，本质上是封装了 Reids 的操作来实现的。&lt;/p>
&lt;p>Redisson 的公平锁的实现原理类似于 ReentrankLock 的公平锁机制，主要维护一个等待队列，通过控制锁的获取顺序来实现。&lt;/p>
&lt;p>Redisson 的看门狗机制目的是检查锁的状态，自动管理分布式锁过期时间。其实现主要通过一个后台线程（俗称看门狗），每隔锁的 1/3 时间检查锁的状态，只要持有锁的线程仍在执行且没有主动释放锁，看门狗就会持续进行续期操作。如果没有线程持有锁，看门狗就会自动释放锁。&lt;/p>
&lt;p>&lt;img src="image/image-1.png" alt="alt text">&lt;/p>
&lt;p>Redisson 通过 RedLock 算法，保证了集群环境中锁的可靠性。&lt;/p>
&lt;p>RedLock 算法的主要目的是为了解决 Master 节点宕机导致锁的释放问题。RedLock 算法的基本思路是，在多个 Redis 节点上同时加锁，只要大多数 Redis 节点都加锁成功，那么加锁成功；如果加锁失败，则释放所有锁并重试。&lt;/p>
&lt;p>RedLock 算法的流程如下：&lt;/p>
&lt;ol>
&lt;li>客户端获取当前时间戳。&lt;/li>
&lt;li>客户端在每个 Redis 节点上尝试用相同的锁名和 UUID 获取锁，并设置一个较短的过期时间。获取成功则记录加锁节点，否则记录失败节点。并记录加锁的总用时。&lt;/li>
&lt;li>如果成功加锁的节点大于等于 N/2+1（N 为 Redis 节点数），并且获取锁的总时间小于锁的过期时间，则认为加锁成功并执行业务逻辑；否则认为获取锁失败，释放所有锁&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="image/image-2.png" alt="alt text">&lt;/p>
&lt;p>Redisson 通过唯一标识与计数器实现了锁的可重入的特性：&lt;/p>
&lt;ol>
&lt;li>每个锁在 Redis 中存储为一个键，键的值是一个唯一标识符（通常是 UUID）和一个计数器。当一个线程第一次获取锁时，Redisson 会在 Redis 中创建一个键，值为当前线程的唯一标识符，并将计数器设置为 1。&lt;/li>
&lt;li>如果同一个线程再次请求获取同一个锁，Redisson 会检测到该线程已经持有锁，因为 Redis 中的值包含该线程的唯一标识符。此时，Redisson 只会增加计数器，而不会再次申请锁。&lt;/li>
&lt;li>当线程释放锁时，Redisson 会减少计数器。只有当计数器减少到 0 时，锁才会真正被释放，Redis 中的键才会被删除。&lt;/li>
&lt;/ol>
&lt;h2 id="分布式锁的选用">分布式锁的选用&lt;/h2>
&lt;h3 id="基于数据库">基于数据库&lt;/h3>
&lt;p>基于数据库的锁，主要是基于数据库的特性：唯一索引、乐观锁版本号自行比对，悲观锁 SELECT &amp;hellip; FOR UPDATE（数据库层面的锁）等。但也有很多问题，所以实际生产环境很少考虑用这把锁。&lt;/p>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>性能问题：数据库的锁基于磁盘数据的 CRUD 操作，必然会造成性能问题。&lt;/li>
&lt;li>可靠性问题：基于数据库的锁，如果数据库宕机，锁也会被释放，导致数据不一致。可以通过集群部署的方式来提高可靠性。&lt;/li>
&lt;li>过期问题：数据库的数据无法自动过期，如果锁一直没有释放，会造成死锁。只能通过自行配置定时任务来清理过期锁。&lt;/li>
&lt;li>重入问题：基于数据库的锁，如果同一个线程再次请求获取同一个锁，数据库会检测到该线程已经持有锁，但是不会再次申请锁，所以无法实现重入。可以通过人为模拟其他重入锁的实现方式（记录唯一 ID，下次访问让这个 ID 对应的计数器值加一，释放锁时让这个 ID 对应的计数器值减一），来实现重入锁。&lt;/li>
&lt;/ol>
&lt;h3 id="基于-zookeeper">基于 Zookeeper&lt;/h3>
&lt;p>基于 Zookeeper 的锁，主要是基于 Zookeeper 的特性：临时顺序节点、watch 机制等。Zookeeper 本身的集群设计就是为了保证强一致性，所以基于 Zookeeper 的锁可以实现较强的一致性。&lt;/p>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>公平性：由于临时顺序节点的机制，Zookeeper 实现的分布式锁天然保证了锁的公平性。&lt;/li>
&lt;li>可重入性：Zookeeper 通过会话 ID 来判断是不是同一个线程访问，所以天然也实现了可重入性。&lt;/li>
&lt;li>锁释放问题：节点释放锁以后会自动被 Zookeeper 删除这个节点，不会出现锁释放导致的问题。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>性能问题：由于关于锁的获取需要节点的创建和释放，并且在集群环境中只能由 Leader 节点来进行操作，所以性能会受到影响。&lt;/li>
&lt;li>其实 Zookeeper 也会有并发问题，在网络抖动的环境下，客户端有时候会突然连不上 Zookeeper，所以锁会被释放供后面的线程获取。但是因为 ZK 有重试机制，所以这种情况很少发生。&lt;/li>
&lt;/ol>
&lt;h3 id="基于-redisson">基于 redisson&lt;/h3>
&lt;p>基于 Redisson 的锁，主要是基于 Redisson 的特性：RedLock 算法、可重入锁等。Redisson 实现了分布式锁的功能，并且提供了一些高级功能，比如：可重入锁、过期锁自动续期、分布式锁监听器等。&lt;/p>
&lt;p>&lt;strong>优点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>集群问题：客户端 A 从 master 节点获取到锁后，由于 Redis 集群部署数据通过异步复制，可能出现 master 宕机以后锁变量未能及时同步到 slave 节点上的情况。当 slave 节点晋升为 master 节点以后，客户端 B 就可以从新的 master 节点中获取锁，这样就导致了一把锁同时被两个客户端获取，破坏了锁的互斥性。而 Redission 的 RedLock 算法一定程度上减少了这个问题的发生。&lt;/li>
&lt;li>可重入性：Redisson 通过锁的计数器变量实现了可重入性。&lt;/li>
&lt;li>自动续期：Redisson 采用看门狗机制，每隔 1/3 的时间检查锁的状态看是否被客户端占有，如果持有锁的线程仍在执行且没有主动释放锁，则自动续期；如果客户端宕机则自动释放锁。&lt;/li>
&lt;li>公平锁：Redisson 通过维护一个等待队列，按照先来先服务的原则，保证了锁的公平性。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>缺点：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>依赖于Redis：如果Redis宕机或者不可用，那么Redisson的锁也会失效。&lt;/li>
&lt;li>性能问题：RedLock算法的执行过程中，也可能会面临一些加锁解锁的性能成本，以及系统时钟比对的问题&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>实际生产环境中，我们一般推荐ZK或者Redis分布式锁。相比之下，ZK的锁的可靠性更高，Redis的锁的性能更好。具体使用那种还是取决于自己的业务需要。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;p>&lt;a href="https://blog.csdn.net/u013474436/article/details/104924782">基于 MySQL 实现的分布式锁&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/weixin_45683778/article/details/144564485">【MySQL】优雅的使用 MySQL 实现分布式锁&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/Fireworkit/article/details/136968331">Zookeeper 实现分布式锁（Zk 分布式锁）&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/hvTx6_WSZ82ok3na7L1IiA">阿里技术-分布式锁实现原理与最佳实践&lt;/a>&lt;/p></description></item></channel></rss>